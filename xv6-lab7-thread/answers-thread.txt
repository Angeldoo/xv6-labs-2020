Q: Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing. Submit your sequence with a short explanation in answers-thread.txt
A: 这里的哈希表就是"数组(bucket)+链表"的经典实现方法. 通过取余确定 bucket, put() 是使用前插法插入键值对, get() 遍历 bucket 下的链表找到对应 key 的 entry. 而这个实现没有涉及任何锁机制或者 CAS 等线程安全机制, 因此线程不安全, 多线程插入时会出现数据丢失.
该哈希表的线程安全问题是: 多个线程同时调用 put() 对同一个 bucket 进行数据插入时, 可能会使得先插入的 entry 丢失. 结合代码具体来讲, 假设有 A 和 B 两个线程同时 put(), 由于该哈希表的桶数 NBUCKET为 5, 哈希函数为 key%NBUCKET, 而插入的 key 为 keys[b*n+i], 而 b=NKEYS/nthread=100000/2=50000, 而 b%NBUCKET==0, 因此对于 A 和 B 两个线程, 在 i 相同时实际上会在同一个 bucket 插入数据. 假设 A 和 B 都运行到 put() 函数的 insert() 处, 还未进入该函数内部, 这就会导致两个线程 insert() 的后两个参数是相同的, 都是当前 bucket 的链表头, 如若线程 A 调用 insert() 插入完 entry 后, 切换到线程 B 再调用 insert() 插入 entry, 则会导致线程 A 刚刚插入的 entry 丢失.
